{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lesgo! A lightweight node.js serverless framework Bootstrap your next microservice with a light-weight node.js serverless framework on AWS. Quick Start Prerequisites Install Serverless Framework globally with: npm install -g serverless . Refer to https://serverless.com/framework/docs/getting-started/ for additional info. Create Serverless project: sls create --template-url https://github.com/reflex-media/lesgo/tree/master --path my-service cd my-service Install dependencies: yarn install Start local: yarn start Access local url via browser or Postman: http://localhost:8181/ping .","title":"Prologue"},{"location":"#lesgo","text":"","title":"Lesgo!"},{"location":"#a-lightweight-nodejs-serverless-framework","text":"Bootstrap your next microservice with a light-weight node.js serverless framework on AWS.","title":"A lightweight node.js serverless framework"},{"location":"#quick-start","text":"Prerequisites Install Serverless Framework globally with: npm install -g serverless . Refer to https://serverless.com/framework/docs/getting-started/ for additional info. Create Serverless project: sls create --template-url https://github.com/reflex-media/lesgo/tree/master --path my-service cd my-service Install dependencies: yarn install Start local: yarn start Access local url via browser or Postman: http://localhost:8181/ping .","title":"Quick Start"},{"location":"404/","text":"404 Page Not Found The page you are looking for does not exist. Return to homepage .","title":"404 Page Not Found"},{"location":"404/#404-page-not-found","text":"The page you are looking for does not exist. Return to homepage .","title":"404 Page Not Found"},{"location":"contributing/","text":"Contributing Interested in contributing to the Lesgo! framework? Want to report a bug? Before you do, please read the following guidelines. Source Repositories! The Lesgo! source code is managed on GitHub, and live on 3 separate repositories: Lesgo! Template This is the main serverless template that developers will in their own project. Lesgo! Framework Most of the core logic exists in this npm package. Lesgo! Documentation Repository for this documentation. Submission context Got a question or problem? Submit an issue to our Github Repository and we'll try our best to follow-up. Found a bug? If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our Github Repository . Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines. Missing a feature? You can request a new feature by submitting an issue to our Github Repository . If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone, as the Lesgo! framework is highly opinionated. Please consider what kind of change it is: For a major feature, first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of the theme. Submission guidelines Submitting an issue Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue. Submitting a Pull Request (PR) Search GitHub for an open or closed PR that relates to your submission. You don't want to duplicate effort. If you do not find a related issue or PR, go ahead. Development : Fork the project, set up the development environment, make your changes in a separate git branch and add descriptive messages to your commits. Pull Request : Commit your changes, push your branch to GitHub and send a PR to lesgo:develop. If we suggest changes, make the required updates, rebase your branch and push the changes to your GitHub repository, which will automatically update your PR. After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository.","title":"Contributing"},{"location":"contributing/#contributing","text":"Interested in contributing to the Lesgo! framework? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"contributing/#source-repositories","text":"The Lesgo! source code is managed on GitHub, and live on 3 separate repositories: Lesgo! Template This is the main serverless template that developers will in their own project. Lesgo! Framework Most of the core logic exists in this npm package. Lesgo! Documentation Repository for this documentation.","title":"Source Repositories!"},{"location":"contributing/#submission-context","text":"","title":"Submission context"},{"location":"contributing/#got-a-question-or-problem","text":"Submit an issue to our Github Repository and we'll try our best to follow-up.","title":"Got a question or problem?"},{"location":"contributing/#found-a-bug","text":"If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our Github Repository . Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines.","title":"Found a bug?"},{"location":"contributing/#missing-a-feature","text":"You can request a new feature by submitting an issue to our Github Repository . If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone, as the Lesgo! framework is highly opinionated. Please consider what kind of change it is: For a major feature, first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of the theme.","title":"Missing a feature?"},{"location":"contributing/#submission-guidelines","text":"","title":"Submission guidelines"},{"location":"contributing/#submitting-an-issue","text":"Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue.","title":"Submitting an issue"},{"location":"contributing/#submitting-a-pull-request-pr","text":"Search GitHub for an open or closed PR that relates to your submission. You don't want to duplicate effort. If you do not find a related issue or PR, go ahead. Development : Fork the project, set up the development environment, make your changes in a separate git branch and add descriptive messages to your commits. Pull Request : Commit your changes, push your branch to GitHub and send a PR to lesgo:develop. If we suggest changes, make the required updates, rebase your branch and push the changes to your GitHub repository, which will automatically update your PR. After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository.","title":"Submitting a Pull Request (PR)"},{"location":"advance/cache/","text":"Cache Lesgo! uses AWS ElastiCache for caching. Configuration This is configurable in the src/config/cache.js . export default { default : memcached , connections : { memcached : { url : process . env . ELASTICACHE_MEMCACHED_URL || null , options : { autoDiscover : true , autoDiscoverInterval : 60000 , autoDiscoverOverridesRemove : false } } } }; Cache Usage Retrieving items in the cache You may use the get method on the Cache function to fetch items in the cache. import cache from Utils/cache ; cache (). get ( key , ( err , data ) = { console . log ( `Logger: err( ${ err } ) data( ${ data } )` ); }); cache (). end (); Storing items in the cache You may use the set method on the Cache function to store items in the cache. import cache from Utils/cache ; const seconds = 10 ; cache (). set ( key , value , seconds , ( err , data ) = { console . log ( `Logger: err( ${ err } ) data( ${ data } )` ); }); cache (). end ();","title":"Cache"},{"location":"advance/cache/#cache","text":"Lesgo! uses AWS ElastiCache for caching.","title":"Cache"},{"location":"advance/cache/#configuration","text":"This is configurable in the src/config/cache.js . export default { default : memcached , connections : { memcached : { url : process . env . ELASTICACHE_MEMCACHED_URL || null , options : { autoDiscover : true , autoDiscoverInterval : 60000 , autoDiscoverOverridesRemove : false } } } };","title":"Configuration"},{"location":"advance/cache/#cache-usage","text":"","title":"Cache Usage"},{"location":"advance/cache/#retrieving-items-in-the-cache","text":"You may use the get method on the Cache function to fetch items in the cache. import cache from Utils/cache ; cache (). get ( key , ( err , data ) = { console . log ( `Logger: err( ${ err } ) data( ${ data } )` ); }); cache (). end ();","title":"Retrieving items in the cache"},{"location":"advance/cache/#storing-items-in-the-cache","text":"You may use the set method on the Cache function to store items in the cache. import cache from Utils/cache ; const seconds = 10 ; cache (). set ( key , value , seconds , ( err , data ) = { console . log ( `Logger: err( ${ err } ) data( ${ data } )` ); }); cache (). end ();","title":"Storing items in the cache"},{"location":"advance/helpers/","text":"Helpers","title":"Helpers"},{"location":"advance/helpers/#helpers","text":"","title":"Helpers"},{"location":"advance/object-store/","text":"Object Store Lesgo! is pre-configured with AWS S3 for object storage. Fetch Object The getObject() function will fetch the object from the Bucket. import { getObject } from Utils/objectStore ; // Returns a buffered object response. See AWS for more information const objectFile = await getObject ( Key , Bucket ); S3 Bucket Permissions Policy To fetch/put objects to an exisitng S3 bucket, be sure to set up an IAM user with the correct permissions as well as updating the S3 bucket policy. You may override the config by updating these in the environment file. # Set IAM access key with S3 access AWS_S3_OPTIONS_ACCESS_KEY_ID = # Set IAM secret key AWS_S3_OPTIONS_SECRET_ACCESS_KEY = # Set S3 region to connect to AWS_S3_OPTIONS_REGION =","title":"Object Store"},{"location":"advance/object-store/#object-store","text":"Lesgo! is pre-configured with AWS S3 for object storage.","title":"Object Store"},{"location":"advance/object-store/#fetch-object","text":"The getObject() function will fetch the object from the Bucket. import { getObject } from Utils/objectStore ; // Returns a buffered object response. See AWS for more information const objectFile = await getObject ( Key , Bucket );","title":"Fetch Object"},{"location":"advance/object-store/#s3-bucket-permissions-policy","text":"To fetch/put objects to an exisitng S3 bucket, be sure to set up an IAM user with the correct permissions as well as updating the S3 bucket policy. You may override the config by updating these in the environment file. # Set IAM access key with S3 access AWS_S3_OPTIONS_ACCESS_KEY_ID = # Set IAM secret key AWS_S3_OPTIONS_SECRET_ACCESS_KEY = # Set S3 region to connect to AWS_S3_OPTIONS_REGION =","title":"S3 Bucket Permissions Policy"},{"location":"advance/queues/","text":"Queues Lesgo! is pre-configured with AWS SQS for queues. Dispatcher The dispatch() function will dispatch a message payload to the queue. Usage This example usage will send a message to the pre-defined PingQueue. import { dispatch } from Utils/queue ; const payload = { someData : someValue , }; return await dispatch ( payload , pingQueue ); Refer to src/core/pingQueue.js for usage example. Consumer The consumer is a lambda function that will process messages payload in the Queue. Refer to src/core/pingQueueProcessor.js for usage example. Automatic Consumption Messages sent to the Queues can be automatically consumed by a Consumer. This can be configured to an event lambda function. Configuring automated queue processor ... Scheduled Consumption Messages sent to a FIFO Queue will need to be manually consumed. This can be configured as a CloudWatch Event. Configuring scheduled queue processor ... Configuring Queue Queues will need to be configured on Serverless via its yaml file before it can be used. Add Serverless Resource Connecting To Separate SQS Instance To connect to a different SQS instance, you may override the config by updating these in the environment file. # Set IAM access key with SQS access AWS_SQS_OPTIONS_ACCESS_KEY_ID = # Set IAM secret key AWS_SQS_OPTIONS_SECRET_ACCESS_KEY = # Set SQS region to connect to AWS_SQS_OPTIONS_REGION = Sample Queue Endpoints /ping/queue Send a ping request queued to SQS. Note : Set x-api-key in your request header for a valid request. /ping/queue?failed-queue Send a ping request queued to SQS as a failed job. Note : Set x-api-key in your request header for a valid request.","title":"Queues"},{"location":"advance/queues/#queues","text":"Lesgo! is pre-configured with AWS SQS for queues.","title":"Queues"},{"location":"advance/queues/#dispatcher","text":"The dispatch() function will dispatch a message payload to the queue.","title":"Dispatcher"},{"location":"advance/queues/#usage","text":"This example usage will send a message to the pre-defined PingQueue. import { dispatch } from Utils/queue ; const payload = { someData : someValue , }; return await dispatch ( payload , pingQueue ); Refer to src/core/pingQueue.js for usage example.","title":"Usage"},{"location":"advance/queues/#consumer","text":"The consumer is a lambda function that will process messages payload in the Queue. Refer to src/core/pingQueueProcessor.js for usage example.","title":"Consumer"},{"location":"advance/queues/#automatic-consumption","text":"Messages sent to the Queues can be automatically consumed by a Consumer. This can be configured to an event lambda function. Configuring automated queue processor ...","title":"Automatic Consumption"},{"location":"advance/queues/#scheduled-consumption","text":"Messages sent to a FIFO Queue will need to be manually consumed. This can be configured as a CloudWatch Event. Configuring scheduled queue processor ...","title":"Scheduled Consumption"},{"location":"advance/queues/#configuring-queue","text":"Queues will need to be configured on Serverless via its yaml file before it can be used.","title":"Configuring Queue"},{"location":"advance/queues/#add-serverless-resource","text":"","title":"Add Serverless Resource"},{"location":"advance/queues/#connecting-to-separate-sqs-instance","text":"To connect to a different SQS instance, you may override the config by updating these in the environment file. # Set IAM access key with SQS access AWS_SQS_OPTIONS_ACCESS_KEY_ID = # Set IAM secret key AWS_SQS_OPTIONS_SECRET_ACCESS_KEY = # Set SQS region to connect to AWS_SQS_OPTIONS_REGION =","title":"Connecting To Separate SQS Instance"},{"location":"advance/queues/#sample-queue-endpoints","text":"/ping/queue Send a ping request queued to SQS. Note : Set x-api-key in your request header for a valid request. /ping/queue?failed-queue Send a ping request queued to SQS as a failed job. Note : Set x-api-key in your request header for a valid request.","title":"Sample Queue Endpoints"},{"location":"advance/task-scheduling/","text":"Task Scheduling Lesgo! utilizes the CloudWatch Scheduled Event type to schedule events. This is the equivalent as you would configured a Cron entry on an application server. Defining Schedules Define a scheduled event by first inserting a function with the event:schedule type in your serverless function yaml. functions: - pingScheduledEvent: handler: src/app/handlers/scheduledEvent.handler description: Lambda event triggered from Scheduled Cloudwatch Event events: - schedule: name: scheduledEvent description: Trigger lambda function every 5 minute rate: rate(5 minutes) enabled: true The above configuration will execute a CloudWatch Scheduled Event every 5 mins. This scheduled event will execute the handler. Refer to config/functions/ping.yml for usage sample.","title":"Task Scheduling"},{"location":"advance/task-scheduling/#task-scheduling","text":"Lesgo! utilizes the CloudWatch Scheduled Event type to schedule events. This is the equivalent as you would configured a Cron entry on an application server.","title":"Task Scheduling"},{"location":"advance/task-scheduling/#defining-schedules","text":"Define a scheduled event by first inserting a function with the event:schedule type in your serverless function yaml. functions: - pingScheduledEvent: handler: src/app/handlers/scheduledEvent.handler description: Lambda event triggered from Scheduled Cloudwatch Event events: - schedule: name: scheduledEvent description: Trigger lambda function every 5 minute rate: rate(5 minutes) enabled: true The above configuration will execute a CloudWatch Scheduled Event every 5 mins. This scheduled event will execute the handler. Refer to config/functions/ping.yml for usage sample.","title":"Defining Schedules"},{"location":"advance/unit-tests/","text":"Unit Tests Lesgo! uses Jest testing framework for unit testing. All test files exist in the tests/ directory. Run Test This command will execute the unit testing. $ yarn test Run Coverage Report This command will execute the unit testing and generate a code coverage report. $ yarn coverage View the generated html report in coverage/index.html . Test environment Declare test environment configurations as NODE variables in tests/setupTest.js .","title":"Unit Tests"},{"location":"advance/unit-tests/#unit-tests","text":"Lesgo! uses Jest testing framework for unit testing. All test files exist in the tests/ directory.","title":"Unit Tests"},{"location":"advance/unit-tests/#run-test","text":"This command will execute the unit testing. $ yarn test","title":"Run Test"},{"location":"advance/unit-tests/#run-coverage-report","text":"This command will execute the unit testing and generate a code coverage report. $ yarn coverage View the generated html report in coverage/index.html .","title":"Run Coverage Report"},{"location":"advance/unit-tests/#test-environment","text":"Declare test environment configurations as NODE variables in tests/setupTest.js .","title":"Test environment"},{"location":"basics/error-handling/","text":"Error Handling It is recommended to always throw an Error class as an exception instead of returning just an error message. You may create your own Error Class within the src/exceptions/ directory. import ValidationError from Errors/ValidationError ; const someFunction = () = { throw new ValidationError ( Content type defined as JSON but an invalid JSON was provided , 40001002 , 400 ); }; Refer to the sample src/core/ping.js for usage. Custom Error Classes You can define your own Error Classes as required. Refer to the existing src/exceptions/ErrorException.js class.","title":"Error Handling"},{"location":"basics/error-handling/#error-handling","text":"It is recommended to always throw an Error class as an exception instead of returning just an error message. You may create your own Error Class within the src/exceptions/ directory. import ValidationError from Errors/ValidationError ; const someFunction = () = { throw new ValidationError ( Content type defined as JSON but an invalid JSON was provided , 40001002 , 400 ); }; Refer to the sample src/core/ping.js for usage.","title":"Error Handling"},{"location":"basics/error-handling/#custom-error-classes","text":"You can define your own Error Classes as required. Refer to the existing src/exceptions/ErrorException.js class.","title":"Custom Error Classes"},{"location":"basics/logging/","text":"Logging Lesgo! is configured with structured logging. Structured logs will appear on the console by default. import logger from Utils/logger ; logger . log ( info , this is an info log ); logger . info ( This is an info log ); logger . warn ( This is a warning log ); logger . error ( This is an error log ); Error logs can also be sent to Sentry. Simply update the relevant DOTenv in the config/environments/ directory. # Enable/disable sentry reporting SENTRY_ENABLED = true # DSN for sentry reporting. Instructions can be found on your Sentry dashboard SENTRY_DSN = # Minimal error to send to Sentry. SENTRY_LEVEL = You may also add additional custom metadata as such: logger . info ( This is an info log with my own custom metadata , { customData1 : someData1 , customData2 : someData2 , });","title":"Logging"},{"location":"basics/logging/#logging","text":"Lesgo! is configured with structured logging. Structured logs will appear on the console by default. import logger from Utils/logger ; logger . log ( info , this is an info log ); logger . info ( This is an info log ); logger . warn ( This is a warning log ); logger . error ( This is an error log ); Error logs can also be sent to Sentry. Simply update the relevant DOTenv in the config/environments/ directory. # Enable/disable sentry reporting SENTRY_ENABLED = true # DSN for sentry reporting. Instructions can be found on your Sentry dashboard SENTRY_DSN = # Minimal error to send to Sentry. SENTRY_LEVEL = You may also add additional custom metadata as such: logger . info ( This is an info log with my own custom metadata , { customData1 : someData1 , customData2 : someData2 , });","title":"Logging"},{"location":"basics/middleware/","text":"Middleware Middlewares can be executed before or after a request, usually handled by the handlers. This will be useful for cases where an action is required prior to reaching the handler, or when an action is required to execute prior to the returning of the response. Middlewares require Middy npm to work. Middlewares should be written in the src/middlewares/ directory. Available Middlewares Lesgo! comes with 6 pre-existing middlewares. You may also import other ready-made middlewares from the Middy repository . Normalize Http Request This middleware will normalize the query string parameters and/or json body in the request into a common handler.event.input . This middleware executes before the handler is called. Usage import middy from middy ; import normalizeHttpRequest from Middlewares/normalizeHttpRequest ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( normalizeHttpRequest ()); Normalize SQS Message This middleware will normalize records coming from sqs message event. The Records object in the handler.event will be normalized into handler.event.collection . This middleware executes before the handler is called. Usage import middy from middy ; import normalizeSQSMessage from Middlewares/normalizeSQSMessage ; const originalHandler = event = { return event . collection ; }; export const handler = middy ( originalHandler ); handler . use ( normalizeSQSMessage ()); Refer to src/handlers/samples/pingQueueProcessor.js for more detailed usage example. Success Http Response This middleware will be executed whenever a successful response is expected to be returned. This middleware executes after the request is processed and before the response is returned. Usage import middy from middy ; import successHttpResponse from Middlewares/successHttpResponse ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( successHttpResponse ()); Error Http Response This middleware will be executed whenever an error response is expected to be returned. This middleware executes after the request is processed and before the response is returned. Usage import middy from middy ; import errorHttpResponse from Middlewares/errorHttpResponse ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( errorHttpResponse ()); Http This middleware combines the normalizeHttpRequest , successHttpResponse , and errorHttpResponse middlewares, and can be used for all http endpoints (configured with API Gateway). Usage import middy from middy ; import httpMiddleware from Middlewares/httpMiddleware ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( httpMiddleware ()); Refer to src/handlers/ping.js for usage. Custom Middlewares You can write your own custom middleware with Middy .","title":"Middleware"},{"location":"basics/middleware/#middleware","text":"Middlewares can be executed before or after a request, usually handled by the handlers. This will be useful for cases where an action is required prior to reaching the handler, or when an action is required to execute prior to the returning of the response. Middlewares require Middy npm to work. Middlewares should be written in the src/middlewares/ directory.","title":"Middleware"},{"location":"basics/middleware/#available-middlewares","text":"Lesgo! comes with 6 pre-existing middlewares. You may also import other ready-made middlewares from the Middy repository .","title":"Available Middlewares"},{"location":"basics/middleware/#normalize-http-request","text":"This middleware will normalize the query string parameters and/or json body in the request into a common handler.event.input . This middleware executes before the handler is called. Usage import middy from middy ; import normalizeHttpRequest from Middlewares/normalizeHttpRequest ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( normalizeHttpRequest ());","title":"Normalize Http Request"},{"location":"basics/middleware/#normalize-sqs-message","text":"This middleware will normalize records coming from sqs message event. The Records object in the handler.event will be normalized into handler.event.collection . This middleware executes before the handler is called. Usage import middy from middy ; import normalizeSQSMessage from Middlewares/normalizeSQSMessage ; const originalHandler = event = { return event . collection ; }; export const handler = middy ( originalHandler ); handler . use ( normalizeSQSMessage ()); Refer to src/handlers/samples/pingQueueProcessor.js for more detailed usage example.","title":"Normalize SQS Message"},{"location":"basics/middleware/#success-http-response","text":"This middleware will be executed whenever a successful response is expected to be returned. This middleware executes after the request is processed and before the response is returned. Usage import middy from middy ; import successHttpResponse from Middlewares/successHttpResponse ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( successHttpResponse ());","title":"Success Http Response"},{"location":"basics/middleware/#error-http-response","text":"This middleware will be executed whenever an error response is expected to be returned. This middleware executes after the request is processed and before the response is returned. Usage import middy from middy ; import errorHttpResponse from Middlewares/errorHttpResponse ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( errorHttpResponse ());","title":"Error Http Response"},{"location":"basics/middleware/#http","text":"This middleware combines the normalizeHttpRequest , successHttpResponse , and errorHttpResponse middlewares, and can be used for all http endpoints (configured with API Gateway). Usage import middy from middy ; import httpMiddleware from Middlewares/httpMiddleware ; const originalHandler = event = { return event . input ; }; export const handler = middy ( originalHandler ); handler . use ( httpMiddleware ()); Refer to src/handlers/ping.js for usage.","title":"Http"},{"location":"basics/middleware/#custom-middlewares","text":"You can write your own custom middleware with Middy .","title":"Custom Middlewares"},{"location":"getting-started/deployment/","text":"Deployment Serverless Framework handles most of the deployment tasks. Lesgo! uses its own deployment script to allow for a more custom deployment process. Deploy Entire Application This command will deploy the entire application to a specific environment. yarn deploy -s { environment } Example deploy yarn deploy -s development Deploy Single Function This command will deploy only a single function to a specific environment. yarn deploy -s { environment } -f { function_name } Example deploy yarn deploy -s development -f Ping Other Available Commands These commands are also available. Invoke a function This command will invoke/trigger a single function. yarn invoke -s { environment } -f { function_name } # Example yarn invoke -s development -f Ping Tail log of a function This command allows you to tail the log of a single function. yarn logs -s { environment } -f { function_name } # Example yarn logs -s development -f Ping Build bundle without deployment This command allows you to build the bundle without doing actual deployment. This might be useful to note the created bundle files and sizes. yarn build -s { environment } # Example yarn build -s development","title":"Deployment"},{"location":"getting-started/deployment/#deployment","text":"Serverless Framework handles most of the deployment tasks. Lesgo! uses its own deployment script to allow for a more custom deployment process.","title":"Deployment"},{"location":"getting-started/deployment/#deploy-entire-application","text":"This command will deploy the entire application to a specific environment. yarn deploy -s { environment }","title":"Deploy Entire Application"},{"location":"getting-started/deployment/#example-deploy","text":"yarn deploy -s development","title":"Example deploy"},{"location":"getting-started/deployment/#deploy-single-function","text":"This command will deploy only a single function to a specific environment. yarn deploy -s { environment } -f { function_name }","title":"Deploy Single Function"},{"location":"getting-started/deployment/#example-deploy_1","text":"yarn deploy -s development -f Ping","title":"Example deploy"},{"location":"getting-started/deployment/#other-available-commands","text":"These commands are also available.","title":"Other Available Commands"},{"location":"getting-started/deployment/#invoke-a-function","text":"This command will invoke/trigger a single function. yarn invoke -s { environment } -f { function_name } # Example yarn invoke -s development -f Ping","title":"Invoke a function"},{"location":"getting-started/deployment/#tail-log-of-a-function","text":"This command allows you to tail the log of a single function. yarn logs -s { environment } -f { function_name } # Example yarn logs -s development -f Ping","title":"Tail log of a function"},{"location":"getting-started/deployment/#build-bundle-without-deployment","text":"This command allows you to build the bundle without doing actual deployment. This might be useful to note the created bundle files and sizes. yarn build -s { environment } # Example yarn build -s development","title":"Build bundle without deployment"},{"location":"getting-started/installation/","text":"Installation Quick Start Prerequisites Install Serverless Framework globally with: npm install -g serverless . Refer to https://serverless.com/framework/docs/getting-started/ for additional info. Create Serverless project: sls create --template-url https://github.com/reflex-media/lesgo/tree/master --path my-service cd my-service Install dependencies: yarn install Start local: yarn start Access local url via browser or Postman: http://localhost:8181/ping . Configuration There are 2 levels of configurations for the Lesgo! framework. The project configurations are stored in config/ directory. These configuration files affect your project set up and build. The application configurations are stored in src/config/ directory. These are application/business specific configurations. Each option is documented, so feel free to look through the files and get familiar with the options available to you. Environment Configuration It is often helpful to have different configuration values based on the environment where the application is running. For example, you may wish to use a different SQS queue locally than you do on your production server. To make this happen, Lesgo! uses the Serverless DOTenv plugin. DOTenv files are stored in config/environments/ directory. The supported environments are currently local , development , staging , production . These environment files can be committed to the source control. To overwrite for your local build, you may create a local DOTenv as such example: .env.development.local . This will allow you to overwrite the existing .env.development without having to commit it. Available Environment Configurations # Declare the environment APP_ENV = development # Enable/disable debug mode APP_DEBUG = true # Determine the region to deploy to AWS_ACCOUNT_REGION = us-west-1 # This name needs to match the aws credentials profile on your local machine AWS_ACCOUNT_PROFILE = slsDevProfile # Set the default timeout for all lambda functions AWS_LAMBDA_TIMEOUT = 3 # Set the default memory size for all lambda functions AWS_LAMBDA_MEMORY_SIZE = 128 # Set the default retention period for all cloudwatch logs AWS_LOG_RETENTION_DAYS = 7 # Define your own custom API Gateway Secret Key AWS_APIGATEWAY_SECRET_KEY = # Maximum size before gzip compression for response AWS_APIGATEWAY_COMPRESSION_MAX_BYTES =","title":"Installation"},{"location":"getting-started/installation/#installation","text":"","title":"Installation"},{"location":"getting-started/installation/#quick-start","text":"Prerequisites Install Serverless Framework globally with: npm install -g serverless . Refer to https://serverless.com/framework/docs/getting-started/ for additional info. Create Serverless project: sls create --template-url https://github.com/reflex-media/lesgo/tree/master --path my-service cd my-service Install dependencies: yarn install Start local: yarn start Access local url via browser or Postman: http://localhost:8181/ping .","title":"Quick Start"},{"location":"getting-started/installation/#configuration","text":"There are 2 levels of configurations for the Lesgo! framework. The project configurations are stored in config/ directory. These configuration files affect your project set up and build. The application configurations are stored in src/config/ directory. These are application/business specific configurations. Each option is documented, so feel free to look through the files and get familiar with the options available to you.","title":"Configuration"},{"location":"getting-started/installation/#environment-configuration","text":"It is often helpful to have different configuration values based on the environment where the application is running. For example, you may wish to use a different SQS queue locally than you do on your production server. To make this happen, Lesgo! uses the Serverless DOTenv plugin. DOTenv files are stored in config/environments/ directory. The supported environments are currently local , development , staging , production . These environment files can be committed to the source control. To overwrite for your local build, you may create a local DOTenv as such example: .env.development.local . This will allow you to overwrite the existing .env.development without having to commit it.","title":"Environment Configuration"},{"location":"getting-started/installation/#available-environment-configurations","text":"# Declare the environment APP_ENV = development # Enable/disable debug mode APP_DEBUG = true # Determine the region to deploy to AWS_ACCOUNT_REGION = us-west-1 # This name needs to match the aws credentials profile on your local machine AWS_ACCOUNT_PROFILE = slsDevProfile # Set the default timeout for all lambda functions AWS_LAMBDA_TIMEOUT = 3 # Set the default memory size for all lambda functions AWS_LAMBDA_MEMORY_SIZE = 128 # Set the default retention period for all cloudwatch logs AWS_LOG_RETENTION_DAYS = 7 # Define your own custom API Gateway Secret Key AWS_APIGATEWAY_SECRET_KEY = # Maximum size before gzip compression for response AWS_APIGATEWAY_COMPRESSION_MAX_BYTES =","title":"Available Environment Configurations"},{"location":"getting-started/structure/","text":"Directory Structure \u251c\u2500\u2500 config | \u251c\u2500\u2500 environments | | \u251c\u2500\u2500 .env | | \u251c\u2500\u2500 .env.local | | \u251c\u2500\u2500 .env.development | | \u251c\u2500\u2500 .env.staging | | \u2514\u2500\u2500 .env.production | \u251c\u2500\u2500 functions | \u251c\u2500\u2500 resources | \u2514\u2500\u2500 utils \u251c\u2500\u2500 src | \u251c\u2500\u2500 config | \u251c\u2500\u2500 constants | \u251c\u2500\u2500 core | \u251c\u2500\u2500 exceptions | \u251c\u2500\u2500 handlers | \u251c\u2500\u2500 middlewares | \u251c\u2500\u2500 services | \u2514\u2500\u2500 utils \u2514\u2500\u2500 tests The Config Directory The config/ directory contains the serverless configurations. The application-specific configs can be found in src/config/ directory instead. Environment Config The config/environments directory contains environment-specific configurations. The environment files are used for both deployment and within application code. You may overwrite env files during a deployment by adding a .local suffix e.g; .env.development.local . This is useful for when you want to deploy to a specific environment but not wanting to overwrite committed values. .env : default environment, served as a local example. .env.local : local environment configuration. This should not be committed. .env.development : development environment configuration. .env.staging : staging environment configuration. .env.production : production environment configuration. Function Config The config/functions/ directory contains the available and declared Serverless functions. Resource Config The config/resources/ directory contains the available and declared Serverless resources. Util Config The config/utils/ directory contains additional Serverless configs where required. The Source Directory The src/ directory contains the main source code for your application. Config Directory The src/config/ directory contains the application configurations. Constant Directory The src/constants/ directory contains any application-specific constants made available throughout your source code. Core Directory The src/core/ directory contains your application's core business logic. Exception Directory The src/exceptions/ directory contains error classes. Handler Directory The src/handlers/ directory contains the entry point for all events. Middleware Directory The src/middlewares/ directory contains the request middlewares. Service Directory The src/services/ directory contains class-based services or modules, usually instantiated. These classes are usually made available in the src/utils/ as helper functions. Util Directory The src/utils/ directory contains helper functions. Test Directory The tests/ directory contains test .spec.js files for unit testing.","title":"Directory Structure"},{"location":"getting-started/structure/#directory-structure","text":"\u251c\u2500\u2500 config | \u251c\u2500\u2500 environments | | \u251c\u2500\u2500 .env | | \u251c\u2500\u2500 .env.local | | \u251c\u2500\u2500 .env.development | | \u251c\u2500\u2500 .env.staging | | \u2514\u2500\u2500 .env.production | \u251c\u2500\u2500 functions | \u251c\u2500\u2500 resources | \u2514\u2500\u2500 utils \u251c\u2500\u2500 src | \u251c\u2500\u2500 config | \u251c\u2500\u2500 constants | \u251c\u2500\u2500 core | \u251c\u2500\u2500 exceptions | \u251c\u2500\u2500 handlers | \u251c\u2500\u2500 middlewares | \u251c\u2500\u2500 services | \u2514\u2500\u2500 utils \u2514\u2500\u2500 tests","title":"Directory Structure"},{"location":"getting-started/structure/#the-config-directory","text":"The config/ directory contains the serverless configurations. The application-specific configs can be found in src/config/ directory instead.","title":"The Config Directory"},{"location":"getting-started/structure/#environment-config","text":"The config/environments directory contains environment-specific configurations. The environment files are used for both deployment and within application code. You may overwrite env files during a deployment by adding a .local suffix e.g; .env.development.local . This is useful for when you want to deploy to a specific environment but not wanting to overwrite committed values. .env : default environment, served as a local example. .env.local : local environment configuration. This should not be committed. .env.development : development environment configuration. .env.staging : staging environment configuration. .env.production : production environment configuration.","title":"Environment Config"},{"location":"getting-started/structure/#function-config","text":"The config/functions/ directory contains the available and declared Serverless functions.","title":"Function Config"},{"location":"getting-started/structure/#resource-config","text":"The config/resources/ directory contains the available and declared Serverless resources.","title":"Resource Config"},{"location":"getting-started/structure/#util-config","text":"The config/utils/ directory contains additional Serverless configs where required.","title":"Util Config"},{"location":"getting-started/structure/#the-source-directory","text":"The src/ directory contains the main source code for your application.","title":"The Source Directory"},{"location":"getting-started/structure/#config-directory","text":"The src/config/ directory contains the application configurations.","title":"Config Directory"},{"location":"getting-started/structure/#constant-directory","text":"The src/constants/ directory contains any application-specific constants made available throughout your source code.","title":"Constant Directory"},{"location":"getting-started/structure/#core-directory","text":"The src/core/ directory contains your application's core business logic.","title":"Core Directory"},{"location":"getting-started/structure/#exception-directory","text":"The src/exceptions/ directory contains error classes.","title":"Exception Directory"},{"location":"getting-started/structure/#handler-directory","text":"The src/handlers/ directory contains the entry point for all events.","title":"Handler Directory"},{"location":"getting-started/structure/#middleware-directory","text":"The src/middlewares/ directory contains the request middlewares.","title":"Middleware Directory"},{"location":"getting-started/structure/#service-directory","text":"The src/services/ directory contains class-based services or modules, usually instantiated. These classes are usually made available in the src/utils/ as helper functions.","title":"Service Directory"},{"location":"getting-started/structure/#util-directory","text":"The src/utils/ directory contains helper functions.","title":"Util Directory"},{"location":"getting-started/structure/#test-directory","text":"The tests/ directory contains test .spec.js files for unit testing.","title":"Test Directory"}]}